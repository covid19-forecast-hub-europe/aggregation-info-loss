---
title: "Characterising information loss due to aggregating epidemic model outputs"
output: html_document
---

```{r set-up, include=FALSE}
# Set up Rmarkdown and workspace -----
library(here)
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
library(patchwork)
knitr::opts_chunk$set(eval = TRUE, echo = FALSE,
                      message = FALSE, warning = FALSE,
                      eval.after = "fig.cap")
options(digits = 2)

local <- TRUE # FALSE = download data from hub git remote, TRUE = use copy in this repo

# import functions
source(here("code", "import-results.R"))
source(here("code", "create-ensembles.R"))

# Prettier formatting -----
# targets
target_levels <- c("BE inc case", "NL inc case", "ES inc case", "BE inc death", "NL inc death")
target_labels <- c("Belgium cases", "Netherlands cases", "Spain cases", "Belgium deaths", "Netherlands deaths")
names(target_levels) <- target_labels
names(target_labels) <- target_levels

# colours for scenarios
scenario_colours <- c("A" = "#e66101",
                      "B" = "#ca0020",
                      "C" = "#0571b0",
                      "D" = "#5e3c99",
                      "Weighted" = "grey50")
```


## Results

```{r load-samples}
# Load samples from all models together with observed data
results <- import_projections(round = 2, local = local, n_model_min = 3) |> 
  mutate(target = ordered(x = paste(location, target_variable),
                          levels = target_levels,
                          labels = target_labels))
```

```{r create-simple-ensembles, warning=FALSE}
# Create two simple ensembles ("Sample", "Quantile")
simple_ensembles <- create_simple_ensembles(results = results, 
                              quantiles = c(0.01, 0.05, 0.25, 0.5, 
                                            0.75, 0.95, 0.99)) |> 
  mutate(target = ordered(x = paste(location, target_variable),
                          levels = target_levels,
                          labels = target_labels))
```

#### Comparison of all ensembles

Figure 1

```{r plot-simple, warning=FALSE, fig.dim=c(8,12)}
# Reshape data for plotting -----
  # ensembles
  plot_simple_ensembles <- simple_ensembles |>
    pivot_wider(names_from = quantile) |>
    mutate(median = q0.5) |>
    select(-q0.5)

  # samples
  plot_samples <- results |>
    mutate(model_sample = paste(location, target_variable, scenario_id,
                                model, sample,
                                sep = "-"),
           # relabel model to None
           model = "None") |>
    rename(q0.5 = value_100k) |>
    select(location, target_variable,
           target_end_date, scenario_id,
           model, model_sample, q0.5)

    # combine data and observations
  plot_ensembles_samples <- bind_rows(plot_simple_ensembles, plot_samples) |>
    left_join(distinct(results,
                       location, target_variable,
                       target_end_date, obs_100k),
              by = c("location", "target_variable", "target_end_date"))

  # Format for plotting -----------------------------------------------------
  plot_ensembles_samples <- plot_ensembles_samples |>
    # set order for facet rows
    mutate(model = ordered(model,
                           levels = c("None",
                                      "Samples",
                                      "Quantiles"),
                           labels = c("i. All models' simulated trajectories",
                                      "ii. Ensemble from trajectories",
                                      "iii. Ensemble from models' quantiles")),
           obs_100k = ifelse(model %in% c("Quantiles", "Samples"), NA, obs_100k))

  # Plot --------------------------------------------------------------
  plot_ensembles_samples <- plot_ensembles_samples |>
    mutate(target = ordered(x = paste(location, target_variable),
                          levels = target_levels,
                          labels = target_labels)) |>
    # filter(target == set_target) |>
    ggplot(aes(x = target_end_date,
               fill = scenario_id, col = scenario_id)) +
    # ----- Geoms
    # ensembles
    geom_ribbon(aes(ymin = q0.01, ymax = q0.99),
                alpha = 0.1, col = NA) +
    geom_ribbon(aes(ymin = q0.25, ymax = q0.75),
                alpha = 0.4, col = NA) +
    geom_line(aes(y = median), size = 1) +
    # model samples
    geom_line(aes(y = q0.5, group = model_sample),
              alpha = 0.1) +
    # observed data as points
    geom_point(aes(y = obs_100k),
               colour = "grey20", size = 0.6, show.legend = FALSE) +
    # ----- Structure
    # facets
    facet_grid(rows = vars(target), cols = vars(model),
               scales = "free", switch = "y") +
    # labels
    labs(x = NULL, y = "Incidence per 100k",
         colour = "Scenario", fill = "Scenario") +
    # colours and scales
    scale_colour_manual(values = scenario_colours,
                        aesthetics = c("colour", "fill")) +
    scale_x_date(breaks = "3 month", date_labels = "%b '%y") +
    # theme
    theme_bw() +
    theme(legend.position = "bottom",
          strip.background = element_blank(),
          strip.placement = "outside",
          strip.text = element_text(face = "bold", size = 10))

plot_ensembles_samples
```

#### Difference between uncertainty ranges

Figure 2

```{r width-ensembles, fig.width = 8}
interval_ensembles <- simple_ensembles |>
  mutate(quantile = as.numeric(as.character(sub("q0", "", quantile))),
         interval = round(2 * abs(0.5 - quantile), 2),
         type = if_else(quantile <= 0.5, "lower", "upper"))
duplicate_median <- interval_ensembles |>
  filter(quantile == 0.5) |>
  mutate(type = "upper")

width <- interval_ensembles |>
  bind_rows(duplicate_median) |>
  filter(scenario_id != "Weighted") |>
  select(-quantile) |>
  pivot_wider(names_from = "type") |>
  # Average across all scenarios and dates
  group_by(round, target, model, interval) |>
  summarise(upper = mean(upper),
            lower = mean(lower),
            .groups = "drop")

width_plot <- width |>
  ggplot(aes(x = interval,
             ymin = lower, ymax = upper,
             group = model,
             colour = model, fill = model)) +
  geom_ribbon(alpha = 0.25) +
  geom_linerange(alpha = 0.25) +
  geom_point(aes(y = lower), alpha = 0.5) +
  geom_point(aes(y = upper), alpha = 0.5) +
  scale_colour_brewer(palette = "Set1") +
  scale_fill_brewer(palette = "Set1") +
  labs(y = "Mean lower and upper incidence per 100k",
       x = "Interval width around median",
       fill = "Ensemble data source",
       colour = "Ensemble data source") +
  facet_grid(rows = vars(target),
             scales = "free_y", switch = "y") +
  theme_bw() +
  theme(legend.position = "bottom",
        strip.background = element_blank(),
        strip.placement = "outside",
        strip.text = element_text(face = "bold", size = 10))

width_plot
```

Figure 2 shows the mean lower and upper incidence per 100,000 population, at increasing distances from the median (interval width). The median estimate is at 0 on the x-axis, and an interval width at 0.98 represents the 1%-99% credibility interval around the median. With increasing levels of uncertainty, the distances between the lower and upper bounds are reduced in an ensemble created from quantile summaries of model simulations, compared to sampled simulated trajectories.

#### Conditioning samples on an increasing amount of data
```{r weekly-ensembles, warning=FALSE}
# Create set of weekly ensembles with progressively increasing observed data
weekly <- create_weekly_ensembles(results)
```

Text:

- When weighted by inverse MAE, no sample received more than `r max(weekly$weights$weight)*100`% weight (among n=`r nrow(weekly$weights)/length(unique(weekly$weights$target))` samples for each target).


Figure 3. Weighted ensemble forecasts of incidence 4, 8, and 16 weeks ahead of available data, with available data increasing weekly over time. Showing median (lines) & 50% quantiles (shaded ribbons). Each sample trajectory started from 30 July 2022 and was weighted using its inverse mean absolute error against all available data. Consecutive weekly forecasts were created from updating weights with each week's observed data. We started with 4 weeks observed data and then created consecutive forecasts at each week, so that weights update with increasing weekly observed data becoming available. This meant the earliest forecast is an ensemble of sample trajectories from the 27 August 2022 (vertical dashed line), using 4 weeks' observed data to weight sample trajectories, and gives a 4 week ahead forecast for the 24 September (start of purple ribbon), an 8 week ahead forecast for the 22 October (start of pink ribbon), and 16 week forecast from 17 December 2022 (start of yellow ribbon). 

```{r plot-weekly-ensembles, warning=FALSE, fig.dim=c(8,8)}
# Plot -------------------------------------------
# set up data for plotting
obs_data <- results |>
    distinct(location, target_variable, target_end_date, obs_100k)

weekly_ensemble_plot <- weekly$ensembles |>
    # select only some horizons
    filter(horizon %in% c(4,8,16)) |>
  # add observed data
    full_join(obs_data, by = c("location", "target_variable", "target_end_date")) |> 
  # shape for plotting
    pivot_wider(names_from = quantile) |>
    mutate(median = q0.5) |>
    select(-q0.5) |>
    mutate(forecast_date = as.Date(forecast_date),
           target = ordered(x = paste(location, target_variable),
                            levels = target_levels,
                            labels = target_labels),
           scenario_id = factor(scenario_id),
           horizon_f = factor(horizon, 
                              levels = c(16,8,4), 
                              labels = c("16 weeks ago", "8 weeks ago", "4 weeks ago")))
horizon_cols <- c("16 weeks ago" = "#a1dab4", 
                  "8 weeks ago" = "#41b6c4", 
                  "4 weeks ago" = "#225ea8")
# Plot
weekly_ensemble_plot <- weekly_ensemble_plot |>
    ggplot(aes(x = target_end_date,
               group = horizon_f,
               col = horizon_f,
               fill = horizon_f
    )) +
    # ----- Geoms
    # ensembles
    geom_ribbon(aes(ymin = q0.25, ymax = q0.75),
                col = NA,
                alpha = 0.6) +
    geom_line(aes(y = median), alpha = 0.5, lwd = 1) +
    # observed data as points
    geom_point(aes(y = obs_100k),
               colour = "grey20", size = 0.6,
               show.legend = FALSE) +
    # show start date of weighted forecasting
    geom_vline(xintercept = as.Date("2022-08-27"),
               lty = 2) +
    # ----- Structure
    # facets
    facet_grid(rows = vars(target),
               scales = "free", switch = "y") +
    # labels
    labs(x = NULL, y = "Incidence per 100k",
         fill = "Conditioned on data up to",
         col = "Conditioned on data up to") +
    # scales
    scale_x_date(limits = c(min(results$target_end_date), as.Date("2023-03-11")),
                 breaks = "1 month", date_labels = "%b '%y") +
    scale_colour_manual(values = horizon_cols,
                        aesthetics = c("fill", "colour")) +
    # theme
    theme_bw() +
    theme(legend.position = "bottom",
          strip.background = element_blank(),
          strip.placement = "outside",
          strip.text = element_text(face = "bold", size = 10))
  
weekly_ensemble_plot
```

We show varying lengths of forecasts repeatedly conditioned on simulated trajectories' performance against each week's data. We start with performance from 4-weeks-observed data and use this to weight an ensemble that forecasts 4, 8, or 16 weeks ahead into the future.

```{r save-plots}
ggsave(filename = here("output", "figure-1.jpg"),
       plot = plot_ensembles_samples, 
       width = 10, height = 8)
ggsave(filename = here("output", "figure-2.jpg"),
       plot = width_plot, 
       width = 5, height = 8)
ggsave(filename = here("output", "figure-3.jpg"), 
       plot = weekly_ensemble_plot,
       width = 6, height = 8)
```
